I2C (or I-squared C) stands for Inter-Integrated Circuit. It has the following features:

- Very common on microcontrollers, suitable for short distances only (typically < 300 mm)
- Widely used for external peripherals  
- Modest speed, typically up to 400 k baud  
- Half-duplex, synchronous, 2-wire bus, bidirectional signalling (devices use open-drain outputs)

#### Data transfer

![[I2C serial communication structure.png]]

The structure follows:
1. Start condition
2. Slave address
3. R/W bit
4. Data byte
5. Acknowledge bit
6. Stop condition

**Bit transfer**

One data bit is transferred during each clock pulse. The data on the SDA line must remain stable during the HIGH period of the clock pulse as changes in the data line at this time will be interpreted as control signals
![[I2C clock transitions.png]]

**Start and stop conditions**

Both data and clock lines remain HIGH when the bus is not busy. A HIGH-to-LOW transition of the data line, while the clock is HIGH is defined as the start condition (S).  
A LOW-to-HIGH transition of the data line while the clock is HIGH is defined as the stop condition (P)
The I2C bus line is open-drained, which means the bus should be pulled up when it is in idle state.  
Start and stop conditions are special events in I2C bus as generally the protocol doesn't allow change of logic level of SDA while SCL is high. 

![[start and stop conditions.png]]


**System configuration**

A device generating a message is a ‘transmitter’, a device receiving is the ‘receiver’. The device that controls the message is the ‘master’ and the devices which are controlled by the master are the ‘slaves’
![[I2C device configuration (multi-slave one-master).png]]


**Acknowledge**
The number of data bytes transferred between the start and the stop conditions from transmitter to receiver is not limited. Each byte of eight bits is followed by one acknowledge bit. (Every 9th cycle) The acknowledge bit is a HIGH level put on the bus by the transmitter whereas the master generates an extra acknowledge related clock pulse.
(0 = `ACK`, 1 = `NACK`) 

A slave receiver which is addressed must generate an acknowledge after the reception of each byte. Also a master must generate an acknowledge after the reception of each byte that has been clocked out of the slave transmitter. The device that acknowledges has to pull down the SDA line during the acknowledge clock pulse, so that the SDA line is stable LOW during the HIGH period of the acknowledge related clock pulse, set-up and hold times must be taken into account. 

Note that acknowledge bit is bi-directional. As mentioned in R/W bit, the data bus is bi-directional. The acknowledge bit can be pulled down by both client and host, depending the data flow direction. 

A master receiver must signal an end of data to the transmitter by not generating an acknowledge on the last byte that has been clocked out of the slave. In this event the transmitter must leave the data line HIGH to enable the master to generate a stop condition.
Note that this may be depending on each hardware, as the above description is provided by a specific I2C module. 

![[ACK NACK bit.png]]


**Client address**

A client address must be specified in I2C protocol, and if multiple devices were used, each device must have a unique client address. If not, there may be a bus collision
Generally it can be a 7-bit or 10-bit address, which immediately follows the Start bit. 
Client address is generally provided in the datasheet, and may contain hardware address A0, A1...
![[slave address examples.png]]

![[hardware address in I2C.png]]


**Read / Write bit**
 Informs the clients if the host would like to read or write the data.  
 1 means read, 0 means write. 
 It can also be regarded as a bus direction indication, which 1 means the client will transfer data to host, and 0 means the client will receive data from host. 

![[Read write bit.png]]



**Data bytes**
The number of data bytes is not limited. 
The content of data bytes may be:
- Word address or register address
- Data to be read/write


##### Some supplementary notes / terminology explain 

**Clock stretching**
Clock stretching is a mechanism used in I2C communication to allow the slave device to slow down the clock signal generated by the master device. This ensures that the slave has enough time to process data and perform other tasks before responding to the master's requests.

In some microcontroller, there is a register bit `CKP`, stands for clock release control. 
In I2C client mode, 1 enables the clock and 0 holds the clock low (clock stretch) 
During clock stretching, if the slave device needs more time to process data, it can hold the SCL line low (stretching the clock) to signal to the master that it is not ready to proceed. The master will then wait until the slave releases the SCL line before continuing with the communication.

Clock stretching is particularly useful in scenarios where the slave device needs to perform time-consuming tasks, such as reading from or writing to external memory, processing sensor data, or executing complex algorithms.

**Repeated start condition**

![[repeated start condition.png]]
Some scenarios when a repeated start condition is wished:
- A bus line with multiple clients, which allows the host to continue transference without termination by simply put a start signal again with different address. 
- Some I2C client devices that interact with memory region and registers must have a repeated start condition to successfully read. 

Almost always a repeated start condition can be applied in the end of any byte transmission. However, it should also be noted that in some application (such as serial EEPROM) there must be a stop condition. Usually datasheet will notify whether a stop condition must be used. 

**Write collision**
Write collision refers to a situation in parallel computing systems or networks where multiple devices attempt to write data to the same resource simultaneously, resulting in a conflict. A conflict, in simple words, is the disagreement of values occurring on a same data line. 
This conflict may lead to **data loss**, **corruption**, or **inconsistency**. 

Write collisions typically occur when multiple devices try to modify the content of a shared resource, such as memory, registers, or files, at the same time. Without proper synchronization mechanisms in place, various scenarios may lead to write collisions: **race condition**, **co-current write**, **timing issue**. 

In order to prevent write collision, 


**General call**
A general call in I2C is a mechanism to broadcast data to all devices connected to the I2C bus simultaneously. It utilizes a reserved address, specifically **0**, to achieve this.
It must be aware that:
- **Addressing all devices:** The master on the bus transmits the address **0**, which signifies a general call. Every slave device on the bus receives this address.
- **Selective reception:** Not all devices need to react to a general call. A slave device programmed to handle general call messages will acknowledge the address (send an ACK signal) and behave as a receiver for subsequent data bytes. Devices that don't require the data simply ignore the call.
- **Master unawareness:** The master initiating the general call isn't informed about how many devices actually respond to the call. It only transmits the data, and any interested slave device receives it.

Some common application of general call:
- **Simultaneous reset:** A specific data byte following the address can be used to trigger a software reset on all responding slave devices.
- **Broadcast configuration data:** By including configuration data in the message, you can set up multiple slave devices with the same settings simultaneously.

#### Register setup

In general, there are several components to be setup in a I2C protocol.

**Setup**
- Mode select
- Clock release control
- I2C enable
- General call enable
- Start / Stop condition enable
- Receive enable
- Acknowledge sequence enable



**Status indication**

- Receiver overflow indicator
- Write collision detect
- Acknowledge status


(**See also: [[Assembly instructions]]**)
The hierarchy of programming language is:

| compiler | assembler | machine code |
| :----: | :----: | :----: |
| higher level | <-> | lower level |
| high readability | <-> | low readability |
| high portability | <-> | low portability |

Generally we use compilers or assemblers for programming, which will emit assembly and machine code. 

#### Benefits and drawbacks of compilation

##### Benefits:

- **Portability**: High level languages are more portable. Moving assembler source code to another processor with a different instruction set architecture will require substantial or possibly total rewrites of code. However, code written in a high level language like C need just be recompiled for the new platform. 
- **Code efficiency**: Creating efficient code is often easier with compiler optimisations than hand- writing that code in assembler language. Compilers can compare multiple different approaches to achieving an outcome and emit, in many cases, the most efficient code to solving it. 
- **Readability**: compiler has higher readability compared to assembler. In addition, the unoptimised C code is usually a lot more readable than the optimised assembler code produced

##### Drawbacks:

- **Hardware-specific limitation**: Some hardware-specific functionality may only be available from assembly (in this case using either inline assembly or a compatible C function written in an assembler language macro can solve the issue)
- **Precise timing**: Precise timing of code may be impossible, due to the inability to predict exactly what code will be generated by the compiler. Function such as "delay 20ms" may need to use assembler to program instead of coming from compiler emission. 
- **Not optimal-performance**: While compilers are very good at optimising code, they are not perfect; hand writing small amounts of code in assembly can be used to achieve optimal performance or program size when this is required


#### Object files and Linkers

From the step of transforming assembly to machine code, sometimes there is an intermediate step, that is generation of object files and linkers. 
##### Objects files 

Object files consist of the program code, but notice that there are some assembler labels that isn't part of the machine code. The jumps/branching statements and external references are unresolved with just object files, hence this is later updated by **linkers**. 
Code is permitted to call functions/jump to labels/address variables that are not defined anywhere in that code, and that code can be compiled into object files. 
Those references are then resolved when the object files are linked together â€“ addresses are updated, code is placed into appropriate locations in program memory. 

##### Linkers 

Linking is an extremely fast step compared to compilation, as only addresses need to be updated. 
Linkers can be smart and exclude code that is not referenced, saving program memory (e.g. link a big library of procedures and only use one; the others can be left out)

Example:
```asm
.global display_decimal
display_decimal:
# Code body
ret
```

#### Keywords for referencing

##### `.global` / `static`

In assembly, symbols are by default private, so ".global" directive is used for explicitly exposing them to be used elsewhere. It is usually convenient to keep most symbols private, as this allows their names to be reused (as assembly has no scope). 

Meanwhile, in compiler, the top-level symbols are public by default, but can be explicitly hidden using the "static" keyword. Static can apply to functions and global variables, and using it means those names can be reused in other objects. Functions/global variables should be static unless they need to be used from other objects. 
Notice that this static has a completely different usage introduced in "static variables". 

##### `.extern` / `extern`

In C, due to types and function arguments, an external variable or function must* be declared first. 
External variables are declared with the 'extern' keyword. 
For example, if global.c contains `int x;` and we wish to use this from main.c, main.c would need to include `extern int x;`
Secondly, external functions need a function prototype declared
The above declarations are commonly placed in header files, meant to be included by code that links the corresponding object file. 
